\newpage
\section{Компилируемый язык}
\label{sec:language}

Компилятор работает с простым языком программирования, основанным на Python 3 и Си.
Образно его можно охарактеризовать как «типизированный Python». Из Python был частично позаимствован синтаксис из-за его высокой читаемости и относительной простоты, а из Си - требования к объявлениям переменных и заголовкам функций.

\subsection{Идентификаторы}

Идентификаторами являются названия локальных переменных, названия функций, названия аргументов функций.
Правила именования состоят в следующем:

\begin{itemize}
    \item идентификатор обязан состоять из одного или более символов;
    \item идентификатор может состоять только из заглавных и строчных букв английского алфавита (A--Z, a--z), цифр от 0 до 9, знака нижнего подчеркивания \_;
    \item идентификатор не может иметь первым символом цифру от 0 до 9 (то есть, не может начинаться с цифры);
    \item идентификатор не может полностью совпадать с любым из ключевых слов языка.

\end{itemize}

Можно отметить, что в целом перечисленные правила справедливы для идентификаторов в языке программирования Си, поэтому с высокой вероятностью будут знакомы для пользователя компилятора.

\subsection{Ключевые слова}

Ключевые слова -- это строго определенные последовательности символов - букв английского алфавита, которые служат для маркировки различных языковых конструкций, например, условных выражений.
Некоторые из ключевых слов также являются операторами, то есть, разделителями операндов в некоторых бинарных операциях.
Полный список зарезервированных слов, специальных для описываемого языка приведен в таблице ниже.

\begin{table}[h]
    \centering
    \caption{Ключевые слова}
    \label{tab:python_keywords}
    \begin{tabular}{>{\ttfamily}l p{11cm}}
        \toprule
        \textrm{\normalfont Ключевое слово} & \textrm{\normalfont Назначение}                      \\
        \midrule
        and                                 & Оператор логической операции «и»                     \\
        bool                                & Название логического (булева) типа данных            \\
        def                                 & Начало объявления функции                            \\
        elif                                & Начало дополнительной ветки в ветвлении              \\
        else                                & Начало альтернативной ветки в ветвлении              \\
        False                               & Обозначение логического нуля или значения «ложь»     \\
        float                               & Название типа данных чисел с плавающей точкой        \\
        for                                 & Начало циклической конструкции со счетчиком          \\
        if                                  & Начало основной ветки в ветвлении                    \\
        int                                 & Название целочисленного типа данных                  \\
        None                                & Название типа данных, не содержащего значение        \\
        or                                  & Оператор логической операции «или»                   \\
        return                              & Описание точки возврата из функции                   \\
        str                                 & Название строкового типа данных                      \\
        True                                & Обозначение логической единицы или значения «истина» \\
        while                               & Начало циклической конструкции с предусловием        \\
        \bottomrule
    \end{tabular}
\end{table}

Кроме того, специфика языка подразумевает еще несколько зарезервированных слов, которые не являются «ключевыми» в полной мере, но интерпретация которых, тем не менее, не может контролироваться пользователем и также предопределена на уровне компилятора.
Такими словами являются:

\begin{itemize}
    \item \verb|main| - название функции - точки входа в программу. Любая программа на описываемом языке обязана иметь реализованную функцию main и ее выполнение начнется именно с этой функции.
    \item \verb|print| - название функции для вывода текста в стандартный поток вывода. Эта функция не может быть переопределена пользователем, и в месте ее упоминания в коде будет вставлен вызов функции printf из стандартной библиотеки языка Си.
    \item \verb|input| - название функции для получения текста из стандартного потока ввода. Эта функция также не может быть переопределена пользователем, и при трансляции будет использоваться функция scanf из стандартной библиотеки языка Си.
    \item \verb|range| - название выражения, напоминающего выхов функции и служащего для явного указания числа итераций в циклах со счетчиком.
    \item \verb|enumerate| - название выражения, напоминающего выхов функции и служащего для неявного указания числа итераций в циклах со счетчиком.
\end{itemize}

\subsection{Операторы}
\label{sec:operators}

Операторы - это определенные последовательности символов, как правило, короткие (состоящие из одного - двух знаков) и небуквенные, служащие преимущественно для отделения операндов в соответствующих операциях.
Многие из операций обозначаются привычными математическими символами и служат для написания арифметико-логических выражений, требуемых к вычислению в процессе выполнения программы.
Полный список значащих операторов и соответствующих им операций представлен в таблице ниже.

\begin{table}[h]
    \centering
    \caption{Операторы}
    \label{tab:operators}
    \begin{tabular}{>{\ttfamily}c p{12cm}}
        \toprule
        \textrm{\normalfont Оператор} & \textrm{\normalfont Назначение (операция)}   \\
        \midrule
        +                             & Сложение                                     \\
        -                             & Вычитание                                    \\
        *                             & Умножение                                    \\
        /                             & Деление или целочисленное деление            \\
        \%                            & Вычисление остатка от целочисленного деления \\
        =                             & Присваивание значения                        \\
        ==                            & Сравнение на равенство                       \\
        !=                            & Сравнение на неравенство                     \\
        >                             & Сравнение «больше»                           \\
        <                             & Сравнение «меньше»                           \\
        >=                            & Сравнение «больше или равно»                 \\
        <=                            & Сравнение «меньше или равно»                 \\
        \verb|[]|                     & Доступ к элементу списка                     \\
        \bottomrule
    \end{tabular}
\end{table}

Отдельно можно выделить круглые скобки: «(» и «)», служащие для группировки операндов в выражениях.
Кроме того, операторами являются ключевые слова «and» и «or», как уже было упомянуто ранее.
Операции имеют различный приоритет при вычислении, который, однако, преимущественно совпадает с общепринятым в математике.

\subsection{Специальные последовательности}
\label{sec:special_sequences}

В языке также определено несколько специальных символьных последовательностей, которые трудно относить к операторам, хоть они и подходят под «внешнее» описание.
Тем не менее, специальные последовательности имеют особое назначение и однозначную интерпретацию.
Приведем их с описанием в таблице~\ref{tab:special_sequences}.

\begin{table}[h]
    \centering
    \caption{Специальные последовательности}
    \label{tab:special_sequences}
    \begin{tabular}{p{3cm}p{12cm}}
        \toprule
        \textbf{Написание}   & \textbf{Назначение}                                                                                                  \\
        \midrule
        \verb|,| (запятая)   & Разделитель аргументов в объявлениях функций, а также в их вызовах                                                   \\
        \addlinespace
        \verb|->| (стрелка)  & Разделитель между списком аргументов функции и типом возвращаемого значения                                          \\
        \addlinespace
        \verb|:| (двоеточие) & Разделитель имени и типа в объявлении переменных, а также выражения и тела (блока) в некоторых языковых конструкциях \\
        \bottomrule
    \end{tabular}
\end{table}

Дополнительно можно упомянуть последовательность из четырех пробелов, именуемую отступом и служащую для обозначения уровней вложенности в блоках кода.
Как и многие другие, эта последовательность была позаимствована из языка программирования Python, но в отличие от Python, число пробелов в ней должно быть фиксированным.

\subsection{Блоки кода}

Блоки в описываемом языке носят характер такой же, как и в других языках программирования, и служат для смыслового разделения частей программы по отношению к функциям и другим языковым конструкциям.
Выделение блоков кода аналогично тому, как это представлено в языке Python.
Каждая строка в программе может иметь в начале 0 или более отступов (см. п.~\ref{sec:special_sequences}).
Идущие непосредственно друг за другом строки считаются принадлежащими одному блоку тогда и только тогда, когда они имеют одинаковое количество отступов в начале.
Число отступов в начале каждой строки не может превышать число отступов в начале предыдущей строки более, чем на 1.
Таким образом, если в текущей строке число отступов на 1 больше, чем в предыдущей, то это значит, что она принадлежит новому блоку кода, вложенному в блок, которому принадлежит предыдущая строка.
Более наглядная демонстрация особенностей, связанных с блоками кода, будет представлена далее в примерах к описаниям языковых конструкций.

\subsection{Типы данных}
\label{sec:data_types}

Описываемый язык имеет определенную систему элементарных (базовых) типов для представления данных (преимущественно числовых) и работы с ними.
Как и в других языках программирования, каждый из типов характеризует множество допустимых значений данных, принадлежащих типу, и список операций, которые можно к ним применять.
Отдельно можно отметить, что представленная в языке типизация является статической, то есть, тип каждого значения, фигурирующего в коде и возникающего во время вычислений при исполнении программы, должен быть либо известен к началу компиляции, либо выведен к ее окончанию.
Все типы данных представлены в таблице~\ref{tab:data_types}.

\begin{table}[h]
    \centering
    \caption{Типы данных}
    \label{tab:data_types}
    \begin{tabular}{lp{4cm}p{6cm}p{3cm}}
        \toprule
        \textbf{Имя} & \textbf{Данные}                    & \textbf{Значения}                                            & \textbf{Аналог в C++} \\
        \midrule
        \verb|bool|  & Логические значения                & True («истина») и False («ложь»)                             & \verb|bool|           \\
        \addlinespace
        \verb|int|   & Целые числа (8 байт)               & От \(-2^{63}\) до \(2^{63} - 1\)                             & \verb|int64_t|        \\
        \addlinespace
        \verb|float| & Числа с плавающей запятой (8 байт) & От $\sim 1.7 \times 10^{-308}$ до $\sim 1.7 \times 10^{308}$ & \verb|double|         \\
        \addlinespace
        \verb|str|   & Строки                             & Последовательность символов                                  & \verb|const char*|    \\
        \addlinespace
        \verb|None|  & Отсутствие значения                & Единственное значение -- None                                & \verb|void|           \\
        \bottomrule
    \end{tabular}
\end{table}

Как можно заметить, тип данных None не является типом в полной мере.
Он служит для обозначения типа возвращаемого значения у функций, которые не должны ничего возвращать.

Помимо элементарных типов, существует также составной тип, называемый list (список).
Он представляет собой последовательность значений, имеющих одинаковый элементарный тип (int или float).
Список имеет фиксированный размер, определяемый в момент его создания, но значения содержащихся в нем элементов могут изменяться в процессе исполнения программы.

\subsection{Арифметико-логические выражения}

Для декларирования необходимых при исполнении программы вычислений язык имеет полную поддержку арифметико-логических выражений, которые записываются в «обычной» (инфиксной) форме.
Выражения могут состоять из операторов, описанных в п.~\ref{sec:operators}, и операндов.
Операндами могут быть:

\begin{itemize}
    \item имена переменных, созданных (объявленных) по коду выше декларируемого выражения - в этом случае вместо имени переменной будет подставлено ее фактическое значение в момент вычисления выражения при выполнении программы;
    \item результаты вызовов функций - в этом случае будет скомпилирован вызов указанной в выражении подпрограммы с возможной передачей аргументов, и при исполнении программы в выражение попадет возвращенное значение;
    \item литеральные выражения или «литералы», то есть конкретные значения одного из встроенных в язык типов в символьной записи - в этом случае значение, которое необходимо подставить в выражение в качестве операнда при вычислении, считается известным на момент компиляции.
\end{itemize}

Для записи литеральных выражений каждого из типов определены некоторые правила.
Эти правила описаны в таблице~\ref{tab:literals}.

\begin{table}[h]
    \centering
    \caption{Литеральные выражения}
    \label{tab:literals}
    \begin{tabular}{lp{8cm}p{4cm}}
        \toprule
        \textbf{Тип данных} & \textbf{Описание записи}                                                                                                                                                     & \textbf{Примеры}  \\
        \midrule
        bool                & Два возможных значения, которые принадлежат этому типу, записываются, соответственно, как True («истина») и False («ложь»).                                                  & ---               \\
        \addlinespace
        int                 & Целые числа записываются с помощью набора символов - цифр от 0 до 9 без пробелов, перед которым дополнительно может находиться знак «минус» в случае отрицательных значений. & 1737, -56, 0      \\
        \addlinespace
        float               & Дробные значения с плавающей точкой записываются в виде десятичных дробей аналогично целым числам, для разделения целой и дробной части используется символ «точка».         & 1.3, -40.716, 0.0 \\
        \addlinespace
        str                 & Строки могут быть записаны в виде последовательности различных символов, обрамленных двойными кавычками.                                                                     & "A", "hello! W"   \\
        \addlinespace
        None                & Единственное значение, которое принадлежит типу, записывается как None.                                                                                                      & ---               \\
        \bottomrule
    \end{tabular}
\end{table}

Опишем также вставку вызова функции.
Вызов функции начинается с ее имени, далее следует пара круглых скобок, в которых через запятую перечисляются аргументы, которые необходимо передать в функцию.
Скобки обязательны, даже если функция не принимает аргументов.
Каждый из аргументов представляет собой отдельное арифметико-логическое выражение и, следовательно, так же может содержать в себе вызовы функций, другие допустимые операнды и операторы.

Внимания заслуживает также бинарная операция доступа к элементу списка.
Ее текстовое представление состоит из имени переменной и арифметико-логического выражения, указываемого далее в квадратных скобках, результатом которого должен являться номер (индекс) нужного элемента.
Нумерация элементов списка ведется с нуля.

\subsection{Объявление переменных}
\label{sec:var_declaration}

Переменные в языке программирования служат для хранения значений и могут быть использованы в арифметико-логических выражениях, в которые при этом будет подставлено фактическое значение переменной.
Отсюда следует, что каждая переменная характеризуется набором из трех компонентов, два из которых задаются при ее объявлении и не могут быть изменены в процессе выполнения программы:

\begin{itemize}
    \item имя (название) переменной (является идентификатором);
    \item тип данных, хранящихся в переменной;
    \item значение переменной (может меняться в процессе выполнения программы).
\end{itemize}

Переменные могут быть объявлены и при необходимости сразу определены (инициализированы) некоторыми значениями.
Инициализация переменных при объявлении не является обязательной, но рекомендуется во избежание возникновения неопределенного поведения при выполнении программы (к этому может привести, например, обращение к переменным, которые не были инициализированы при объявлении и которым не было присвоено какое-либо значение впоследствии).

Объявление переменной начинается с ее имени, далее следует разделитель (двоеточие) и имя типа (см. п.~\ref{sec:data_types}).
После этого может быть указано начальное значение переменной, предваряемое знаком равенства.
Каждое такое объявление должно начинаться на отдельной строке, при этом на одной строке не может быть более одного объявления переменной.
Следует также отметить, что имена переменных обязаны быть уникальными в пределах одного блока.
Нельзя переопределять переменные с одинаковыми названиями.

\begin{lstlisting}[language=Python, caption=Примеры объявлений переменных]
my_int: int = 5
another_int: int
my_float: float = 9.2
another_float: float = my_float * 4
\end{lstlisting}

Как видно из примеров, определение переменной может использовать значения ранее определенных переменных.
Переменные типа None явно объявлены быть не могут.

Отдельно стоит отметить объявление переменных-списков.
При указании типа такой переменной также указывается тип элементов списка в квадратных скобках.
В качестве инициализирующего значения, которое в случае списка обязано присутствовать в объявлении, может быть указана одна из следующих конструкций:

\begin{itemize}
    \item для списка с автоматическим выведением размера: значения элементов списка, разделенные запятыми и обрамленные квадратными скобками;
    \item для списка с размером, передаваемым с помощью арифметического выражения: значение, инициализирующее все элементы списка, в квадратных скобках, оператор умножения и выражение, определяющее размер списка.
\end{itemize}

\begin{lstlisting}[language=Python, caption=Примеры объявлений переменных типа list]
static_list: list[int] = [2, 4, 6, 8, 10]
dynamic_list: list[float] = [1.2] * 50
another_dynamic_list: list[int] = [0] * (a + b - 1)
\end{lstlisting}

\subsection{Объявление функций}

Подпрограммы, служащие для переиспользования кода по принципам процедурного программирования и повышения читаемости программы в целом, в описываемом языке представлены в виде функций.
Функции уже упоминались ранее при описании арифметико-логических выражений.
Объявление функции состоит из заголовка (сигнатуры) функции и ее реализации (определения).
Заголовок должен включать в себя:

\begin{itemize}
    \item имя (название) функции (является идентификатором);
    \item список аргументов (если они требуются);
    \item тип возвращаемого значения.
\end{itemize}

Список аргументов представляет собой, по сути, набор объявлений, схожих с объявлениями переменных, описанных в п.~\ref{sec:var_declaration}, перечисленных через запятую.
В каждом объявлении указывается имя переменной-аргумента, с которым она попадет в тело функции при ее вызове, и ее тип, разделенные двоеточием.

Таким образом, объявление функции начинается с ключевого слова \verb|def|, затем следует имя.
Далее идет список аргументов в паре круглых скобок.
Если функция не должна принимать аргументов, то указываются только открывающая и закрывающая круглые скобки.
После этого должна находиться специальная последовательность «стрелка» (см. п.~\ref{sec:special_sequences}) и название типа возвращаемого значения.
Если функция ничего не возвращает, следует указать тип None.
Заголовок функции заканчивается двоеточием, и с новой строки записывается тело (реализация) функции.
При этом оно должно находиться внутри отдельного (вложенного) блока кода, то есть, каждая строка обязана предваряться отступом.
Необходимо, чтобы тело функции содержало как минимум одну непустую строку.

\begin{lstlisting}[language=Python, caption=Примеры объявлений функций]
def func(arg1: int, arg2: float) -> float:
    x: int = arg1 + 3
    y: float = x - arg2
    return x * y

def another_func() -> int:
    return 3
\end{lstlisting}

Как можно заметить, передаваемые аргументы могут быть использованы непосредственно в выражениях без дополнительных объявлений в теле функции - достаточно их упоминания в заголовке.
Также, для указания возвращаемого значения используется ключевое слово return, за которым следует арифметико-логическое выражение.

\subsection{Условия (ветвления)}

Ветвление в программе может быть достигнуто при помощи особых языковых конструкций - условий.
Условие начинается с ключевого слова if, за которым следует проверяемое арифметико-логическое выражение и двоеточие.
После этого следует основная ветка - с новой строки в отдельном (вложенном) блоке указывается код, который должен быть выполнен, в случае если проверяемое условие окажется истинным в момент исполнения программы.
Если же условие будет ложным, то код основной ветки не будет выполнен и управление перейдет к командам после него.

При необходимости может быть добавлена альтернативная ветка - код в ней будет выполнен только в том случае, если проверяемое выражение окажется ложным.
Для этого используется ключевое слово else, за которым так же следует двоеточие.

Помимо этого, после основной ветки могут быть добавлены дополнительные, при чем у каждой из них будет «собственное» проверяемое выражение.
Такой «каскад» последовательно проверяемых веток записывается в коде практически так же, как и условие и тело основной ветки, с той лишь разницей, что для дополнительных веток используется ключевое слово elif вместо обычного if. Как следует из описания и специфики веток в конструкции условия (ветвления), части, начинающиеся с elif, должны идти после первой части, начинающейся с if, а часть, начинающаяся с else, может находиться только после них, то есть, в самом конце конструкции.

В каждом блоке в вышеперечисленных ветках, разумеется, могут находиться любые объявления переменных, арифметико-логические выражения, другие условные конструкции, а также циклы (см. п.~\ref{sec:loops}).
Таким образом, все языковые конструкции могут комбинироваться между собой в целях достижения требований к программе.

В примерах, приведенных далее, для простоты положим, что все используемые переменные объявлены и инициализированы некоторым корректным образом ранее в коде.

\begin{lstlisting}[language=Python, caption=Примеры условных конструкций]
if a == 1:
    b = 2

if c + 3 < d - 4:
    e: int = 5
    f = g - h
else:
    i = 6

if j >= 7 and k == 8.9:
    l = 10
elif m == 11:
    n: int = 12
elif o > 13.14 or p == 17:
    q: int = 5

if q > 0:
    q = 0
else:
    r = 15.16 + s
\end{lstlisting}

\subsection{Циклы}
\label{sec:loops}

В описываемом языке присутствует еще один род конструкций, присущих подходам структурного программирования -- это цикл.
Реализация поддерживает два вида циклов: цикл с предусловием и цикл со счетчиком. В общем случае цикл содержит преамбулу, определяющую проверяемое выражение, и непосредственно тело цикла -- код, который будет выполняться повторно до тех пор, пока вычисляемое перед каждым проходом цикла (итерации) выражение остается истинным.
В том случае, если выражение окажется ложным, цикл остановится и начнет выполняться код после описываемой конструкции.

Конструкция цикла с предусловием начинается с преамбулы: ключевого слова while, далее указывается контролируемое арифметико-логическое выражение, после этого идет двоеточие и, с новой строки, непосредственно тело цикла в отдельном (вложенном блоке).
Как и в случае с другими конструкциями, код в теле цикла может содержать в себе другие циклы, условия и прочие описанные ранее элементы языка.

В примерах, приведенных далее, для определенности будем считать, что все используемые переменные объявлены и инициализированы некоторым корректным образом ранее в коде.

\begin{lstlisting}[language=Python, caption=Пример цикла с предусловием]
while a != b or c < 17:
    a = a - 1
    c = c + d
\end{lstlisting}

Цикл со счетчиком устроен более сложно.
Преамбула начинается с ключевого слова \verb|for|, далее указывается одна или две цикловые переменные, затем следуют: ключевое слово \verb|in|, конструкция, регулирующая число итераций, и двоеточие.
С новой строки перечисляется тело цикла во вложенном блоке.
В описывемом языке поддерживаются три конфигурации цикла со счетчиком:

\begin{itemize}
    \item Явное указание числа итераций.
          Число итераций регулируется конструкцией вида \verb|range(|\(Start, Stop, Step\)\verb|)|, где все аргументы являются арифметико-логическими выражениями.
          Цикловой переменной является счетчик, изменяющийся в диапазоне от \(Start\) (включительно) до \(Stop\) (не включительно) с шагом \(Step\).
          Параметры \(Start\) и/или \(Step\) могут быть опущены, в этом случае они принимаются равными 0 и 1 соответственно.
    \item Обход списка по значениям.
          Число итераций регулируется конструкцией, состоящей из имени переменной-списка.
          В этом случае цикловой переменной является значение элемента из указанного списка, номер которого соответствует номеру итерации цикла.
    \item Обход списка по номерам (индексам) и значениям.
          Число итераций регулируется конструкцией вида \verb|range(|\(List\)\verb|)|, где \(List\) является именем переменной-списка.
          В этой конфигурации необходимо указывать две цикловые переменные, которым на каждой итерации будут присваиваться индекс и значение элемента списка соответственно.
\end{itemize}

\begin{lstlisting}[language=Python, caption=Примеры циклов со счетчиком]
for i in range(0, 10, 2):
    print(i)

for i in range(7):
    for j in range(1, a + b - 1):
        c = c + 1

for value in my_list:
    x = value - x

for i, value in enumerate(my_list):
    another_list[i] = value * 0.1
\end{lstlisting}

\subsection{Обобщение}

В заключение можно сделать вывод, что компилируемый язык представляет собой некоторую упрощенную вариацию существующих императивных языков программирования (Python, Си) и поддерживает многие конструкции, благодаря которым при написании программ на описываемом языке можно руководствоваться подходами процедурного (поддержка подпрограмм - функций) и структурного (наличие основных конструкций для линейного исполнения кода, ветвлений и циклов) программирования.
Тем не менее, в отличие от оригинального языка Python, в описанном языке отсутствует поддержка таких основных возможностей, как:

\begin{itemize}
    \item более сложные составные типы (словари, кортежи, списки с элементами различающихся типов);
    \item пользовательские типы (классы) и методы;
    \item обработка исключений;
    \item модули и импортирование библиотек.
\end{itemize}
