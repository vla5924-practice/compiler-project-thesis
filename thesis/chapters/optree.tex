\newpage
\section{Дерево операций}
\label{sec:optree}

\subsection{Актуальность применения подхода SSA}
\label{sec:optree_ssa}

Как уже было упомянуто, один из этапов компиляции -- синтаксический анализ.
Реализующий модуль, получая на вход список токенов, в качестве выхода строит синтаксическое дерево.
Такое дерево, помимо прочего, обладает определенными особенностями, среди которых были выделены преимущества и недостатки.

\textbf{Преимущества:}

\begin{itemize}
    \item Синтаксическое дерево легко строится напрямую из списка токенов (или даже текста программы, если лексический анализ совместить с построением дерева) за один проход фактически без дополнительных структур данных.
    \item Синтаксическое дерево является представлением входной программы один-в-один (текст программы может быть восстановлен путем полного обхода дерева), поэтому удобно предоставлять диагностику пользователю (указание точного места в исходном коде).
\end{itemize}

\textbf{Недостатки:}

\begin{itemize}
    \item Процесс семантического анализа дерева нетривиален. Требуется задействовать дополнительные структуры данных для упорядочения информации (список переменных, функций) и т. д.
    \item Применение существенных трансформаций (оптимизаций) является трудоемким: для обнаружения и проверки инвариантов требуется выполнять обходы по несколько раз (анализ использования переменных, вывод типов, поиск определений), что верно и для замены узлов дерева.
\end{itemize}

Для разрешения описанных трудностей, связанных, в частности, с анализом потока данных для выполнения трансформаций, было предложено использовать подход, похожий на SSA.

SSA (static single assignment, статическое единственное присвоение) -- это представление программы, в котором у каждой переменной есть единственное определение, сопровождающееся инициализацией.
Следующие примеры псевдокода демонстрируют одну и ту же программу, записанную в произвольной форме и в форме SSA.

\begin{lstlisting}[language=Python, caption=Программа в произвольной форме]
x = 1
y = x + 1
x = 2
z = x + 1
\end{lstlisting}

% Разрыв страницы
\clearpage

\begin{lstlisting}[language=Python, caption=Программа в форме SSA]
x1 = 1
y = x1 + 1
x2 = 2
z = x2 + 1
\end{lstlisting}

Используя свойство единственности присваивания, можно отследить, как было получено то или иное значение, обойдя цепочку определений и использований переменных.

В классическом подходе SSA, используемом в современных компиляторах, все высокоуровневые конструкции языка, такие как ветвления и циклы, разбиваются на последовательность базовых блоков программы, между которыми явно указываются переходы.
Кроме того, вводится понятие \(\phi\)-узлов, связывающих пути, по которым приходит определение переменной из разных блоков при нелинейном исполнении \cite{vladimirov}.

В настоящей работе была реализована структура данных, использующая подход SSA в упрощенной форме, достаточной для достижения поставленных целей.
Эта структура, названная деревом операций, описана далее.

\subsection{Описание дерева операций}

Дерево операций -- это дополнительное промежуточное представление исходной программы.
В общем случае узлами дерева являются операции, которые обмениваются между собой значениями, каждое из которых определяется своим типом \cite{mlir_intro}.

Как видно на рисунке~\ref{fig:optree_scheme}, операция может иметь произвольное число операндов, не более одного результата, произвольное число атрибутов (вспомогательных данных, независимых от других операций), произвольное число вложенных операций внутри, а также объемлющую операцию, в теле которой указанная операция и находится.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{images/optree-scheme.png}
    \caption{Дерево операций}
    \label{fig:optree_scheme}
\end{figure}

\textbf{Операция} владеет внешними значениями (результатами) и внутренними регистрами.
Результаты видны соседям операции и могут быть операндами других операций, но не видны операциям внутри тела.
Внутренние регистры, наоборот, доступны для использования операциями внутри тела, но снаружи не видны (как переменные во вложенном блоке в C++).
Операция не владеет операндами, так как это результаты или внутренние регистры других операций.
Также внутри хранится имя операции и код, определяющий ее вид (см. п.~\ref{sec:optree_rtti}).
Виды поддерживаемых операций представлены в п.~\ref{sec:optree_operations}.

\textbf{Значение} -- это единоразово определяемый неизменяемый регистр (как const переменная в C++).
Значение нельзя <<изменить>>, но можно создать новую операцию, которая будет иметь нужное значение в качестве результата, а старое значение отбросить (при необходимости удалить порождающую его операцию из дерева).
Значение хранит внутри себя породившую операцию, тип, список использований (операций, среди операндов которых есть указанное значение).

\textbf{Тип} -- это характеристика представления значения; неизменяемая структура, содержащая информацию, полезную для, собственно, представляемого типа.
Система типов в дереве операций сходна с системой типов компилируемого языка (см. п.~\ref{sec:optree_types}).

\textbf{Атрибут} -- это вспомогательные данные, которые используются для анализа операции (какое-либо численное значение, тип, подвид операции, строка и так далее).
Например, операция, описывающая функцию, может иметь имя функции и тип в качестве атрибутов, а операция, описывающая объявление константы -- значение и тип константы и т. д.

К особенностям дерева операций можно отнести следующее:

\begin{itemize}
    \item Дерево операций можно построить из синтаксического дерева за один проход.
    \item Анализ использования значения представляет собой обход готового списка.
    \item Добавление или изменение операций прозрачно: операция хранит информацию о своем положении в дереве, значение хранит информацию о связанной операции и типе.
    \item Невозможно восстановить текст исходной программы напрямую, но можно ссылаться на исходный код в диагностике для пользователя, если сохранить ссылки на места в коде внутри операций при их создании из улов синтаксического дерева.
\end{itemize}

\subsection{Динамическая идентификация типов операций}
\label{sec:optree_rtti}

Динамическая идентификация типа данных (run-time type identification, RTTI) -- механизм в некоторых языках программирования, который позволяет определить тип данных переменной или объекта во время выполнения программы.
Существует множество реализаций такого механизма, но наиболее распространёнными являются:

\begin{itemize}
    \item таблица указателей на объекты;
    \item хранение информации об объекте в памяти вместе с ним.
\end{itemize}

Таким образом, операция определения типа сводится либо к поиску в таблице, либо к просмотру нескольких байт до адреса, на который указывает указатель на объект.
У каждого способа есть свои преимущества и недостатки.
К примеру, в первом случае для определения типа переменной требуется производить операции поиска по таблице указателей.
А во втором случае, переменные начинают занимать больше места в оперативной памяти, чем ожидается, ведь к их известному размеру добавляется некоторое количество байтов, нужных для идентификации их типа.

В настоящей работе для операций используется второй подход.
Для создания операций конкретного типа используются классы-адаптеры, каждый из которых представляет определенную операцию и имеет, помимо прочего, статический метод, возвращающий идентификатор типа операции.

\begin{lstlisting}[language=C++, caption=Фрагмент реализации RTTI]
struct ConcreteOp : public BaseOp {
    // ...

    static Operation::SpecId getSpecId() {
        static char specId = 0;
        return &specId;
    }

    static bool implementsSpecById(Operation::SpecId specId) {
        return specId == getSpecId() || BaseOp::implementsSpecById(specId);
    }
};
\end{lstlisting}

Таким образом, при создании конкретной операции в нее также записывается значение идентификатора типа операции из связанного адаптера.
Это позволяет реализовать для класса операции следующие методы, использующие RTTI:

\begin{lstlisting}[language=C++, caption=Интерфейс для доступа к RTTI]
struct Operation {
    using SpecId = void *;
    SpecId specId;
    // ...

public:
    template <typename AdaptorType> bool is() const;
    template <typename AdaptorType> AdaptorType as();
    template <typename AdaptorType> AdaptorType findParent() const;
    // ...
};
\end{lstlisting}

Эти методы позволяют проверить, является ли операция конкретной операцией, привести ее к указанному типу, а также найти в дереве операций среди предков узла операцию, имеющую определенный тип. Реализованный механизм применяется во многих компонентах проекта, работающих с деревом операций, например, в семантическом анализаторе.

\subsection{Система типов в дереве операций}
\label{sec:optree_types}

Для дерева операций была разработана система типов значений, схожая с системой типов данных компилируемого языка (см. п.~\ref{sec:data_types}).
Элементарные типы, наряду со связанными типами из компилируемого языка, представлены в таблице~\ref{tab:optree_basic_types}.

\begin{table}[h]
    \centering
    \caption{Элементарные типы}
    \label{tab:optree_basic_types}
    \begin{tabular}{lp{9cm}p{3cm}}
        \toprule
        \textbf{Название}  & \textbf{Описание}                      & \textbf{Связанный тип} \\
        \midrule
        \verb|IntegerType| & Целочисленное значение размером 8 байт & \verb|int|             \\
        \verb|BoolType|    & Целочисленное значение размером 1 байт & \verb|bool|            \\
        \verb|FloatType|   & Вещественное значение размером 8 байт  & \verb|float|           \\
        \verb|StrType|     & Массив символов размером по 1 байт     & \verb|str|             \\
        \verb|NoneType|    & Данные, не содержащие значения         & \verb|None|            \\
        \bottomrule
    \end{tabular}
\end{table}

Также присутствуют следующие составные типы:

\begin{itemize}
    \item \verb|FunctionType| -- функциональный тип.
          Используется для хранения заголовков функций, задается с помощью типа возвращаемого значения и списка типов аргументов.
    \item \verb|PointerType| -- внутреннее представление указателя.
          Используется для работы с переменными и списками, задается с помощью типа хранимого значения и, опционально, количества элементов, последовательно расположенных в памяти (размера списка).
\end{itemize}

\subsection{Список поддерживаемых операций}
\label{sec:optree_operations}

Каждая операция в дереве имеет название и идентификатор ее вида, определяющий ее назначение.
В общем случае, операция является абстракцией над одной или несколькими инструкциями в исполняемом файле, которые соответствуют ее семантике.
Например, арифметической бинарной операции обычно соответствует одна инструкция, вычисляющая результат заданной операции.
В то же время, операция, задающая цикл, при построении исполняемого файла должна быть развернута в целый набор вычислений и условных переходов.

Операции, реализованные в настоящей работе, можно разделить на несколько групп:

\begin{itemize}
    \item \textbf{Фундаментальные операции.}
          Операции в этой группе служат для задания основных <<блоков>> программы: объявления и вызова функций, введения констант.
          В группу входят следующие операции:
          \verb|ModuleOp, FunctionOp, FunctionCallOp, ReturnOp, ConstantOp|.
    \item \textbf{Вычислительные операции.}
          Эти операции являются репрезентацией вычисления всевозможных арифметико-логических выражений.
          В группу входят следующие операции:
          \verb|ArithBinaryOp, LogicBinaryOp, ArithCastOp, ArithUnaryOp, LogicUnaryOp|.
    \item \textbf{Операции по работе с памятью.}
          Указанной группе принадлежат операции, работающие с низкоуровневым представлением памяти для явной аллокации, загрузки и сохранения значений.
          В группу входят следующие операции:
          \verb|AllocateOp, LoadOp, StoreOp|.
    \item \textbf{Операции над потоком управления.}
          Операции в этой группе используются для декларирования условных и цикловых конструкций, а также их компонентов.
          В группу входят следующие операции:
          \verb|IfOp, ThenOp, ElseOp, WhileOp, ConditionOp, ForOp|.
    \item \textbf{Специальные операции.}
          Эти операции представляют собой высокоуровневые языковые конструкции, которые должны сохраниться и в низкоуровневом представлении.
          В группу входят следующие операции:
          \verb|InputOp, PrintOp|.
\end{itemize}

В соответствии со своим назначением, каждая операция обязана иметь заданное количество операндов, результирующих значений, внутренних регистров, атрибутов.
За проверку корректности этих, а также и других параметров, присущих операции, отвечает семантический анализатор, описанный в п.~\ref{sec:semantizer}.

\subsection{Обзор структур данных}

В программной реализации каждая сущность дерева представлена классом или набором классов.
Так, операции соответствует класс \verb|Operation|, в котором хранится информация об операндах, результатах, атрибутах, вложенных операциях, положении операции в теле родительской операции и т. д. Методы RTTI, описанные в п.~\ref{sec:optree_rtti}, здесь не приводятся.

\begin{lstlisting}[language=C++, caption=Объявление класса операции]
struct Operation {
    using Ptr = std::shared_ptr<Operation>;
    using Body = std::list<Ptr>;

    Ptr parent;
    Body::iterator position;
    std::string_view name;

    std::vector<Value::Ptr> operands;
    std::vector<Value::Ptr> results;
    std::vector<Value::Ptr> inwards;
    std::vector<Attribute> attributes;
    Body body;

    template <typename VariantType>
    Attribute &addAttr(const VariantType &value);
    void addOperand(const Value::Ptr &value);
    Value::Ptr addResult(const Type::Ptr &type);
    Value::Ptr addInward(const Type::Ptr &type);
    void addToBody(const Ptr &op);

    void erase();
    Ptr clone();

    template <typename AdaptorType>
    static AdaptorType make(const Ptr &parent, const Body::iterator &position);
    static Ptr make(std::string_view name, const Ptr &parent, const Body::iterator &position);
    // ...
};
\end{lstlisting}

Для удобства создания операций конкретных видов, а также доступа к относящимся к ним сущностям, используются классы-адаптеры.
Все они наследуются от базового класса, с помощью которого можно также обращаться к операции, для которой применяется адаптер.

\begin{lstlisting}[language=C++, caption=Объявление базового класса адаптера]
struct Adaptor {
    Operation::Ptr op;

    Adaptor();
    Adaptor(const Operation::Ptr &op);

    operator bool() const;
    operator const Operation::Ptr &() const;
    Operation *operator->() const;

    static std::string_view getOperationName();
    static Operation::SpecId getSpecId();
    static bool implementsSpecById(Operation::SpecId);
};
\end{lstlisting}

Каждый адаптер должен реализовывать метод \verb|init|, который применяется для инициализации операции.
Инициализация включает в себя добавление необходимых операндов, результатов и атрибутов, соответствующих семантике операции.
Для объявления конкретного адаптера также могут быть использованы специальные макросы, заменяющиеся на методы, необходимые, например, для доступа к операнду по его имени.
Например, для адаптеров бинарных операций введена следующая иерархия:

% Разрыв страницы
\clearpage

\begin{lstlisting}[language=C++, caption=Объявление адаптеров для бинарных операций]
struct BinaryOp : Adaptor {
    OPTREE_ADAPTOR_HELPER(Adaptor, "Binary")
    OPTREE_ADAPTOR_OPERAND(lhs, setLhs, 0)
    OPTREE_ADAPTOR_OPERAND(rhs, setRhs, 1)
    OPTREE_ADAPTOR_RESULT(result, 0)

    void init(Type::Ptr resultType, Value::Ptr lhs, Value::Ptr rhs);
};

struct ArithBinaryOp : BinaryOp {
    OPTREE_ADAPTOR_HELPER(BinaryOp, "ArithBinary")
    OPTREE_ADAPTOR_ATTRIBUTE(kind, setKind, ArithBinOpKind, 0)

    void init(ArithBinOpKind kind, Type::Ptr resultType, Value::Ptr lhs, Value::Ptr rhs);
    void init(ArithBinOpKind kind, Value::Ptr lhs, Value::Ptr rhs);
};

struct LogicBinaryOp : BinaryOp {
    OPTREE_ADAPTOR_HELPER(BinaryOp, "LogicBinary")
    OPTREE_ADAPTOR_ATTRIBUTE(kind, setKind, LogicBinOpKind, 0)

    void init(LogicBinOpKind kind, Value::Ptr lhs, Value::Ptr rhs);
};
\end{lstlisting}

Для работы со значениями, коими являются операнды, результаты и внутренние регистры операции, используется класс \verb|Value|.
Значение хранит список использований себя в качестве операндов и имеет вспомогательные методы для сравнения типов.

\begin{lstlisting}[language=C++, caption=Объявление класса значения]
struct Value {
    using Ptr = std::shared_ptr<Value>;
    using BackRef = std::weak_ptr<Operation>;

    struct Use {
        BackRef user;
        size_t operandNumber;

        Use(const BackRef &user, size_t operandNumber);
        Operation::Ptr lock() const noexcept;
        bool userIs(const Operation *op) const noexcept;
    };

    Type::Ptr type;
    BackRef owner;
    std::forward_list<Use> uses;

    Value(const Type::Ptr &type, const BackRef &owner);
    bool hasType(const Type::Ptr &other) const;
    bool sameType(const Value::Ptr &other) const;
    bool canPointTo(const Value::Ptr &other) const;

    template <typename... Args> static Ptr make(Args... args);
    // ...
};
\end{lstlisting}

Каждому значению соответствует тип, представленный базовым классом \verb|Type| и его наследниками (для каждого из типов, описанных в п.~\ref{sec:optree_types}).
В отличие от операций, для динамической идентификации дочерних классов типов в реализации методов \verb|is| и \verb|as| используется классический для C++ подход, включающий использование \verb|dynamic_cast| вкупе с динамическим полиморфизмом.

\begin{lstlisting}[language=C++, caption=Объявление базового класса типа]
struct Type {
    using Ptr = std::shared_ptr<const Type>;
    using PtrVector = std::vector<Type::Ptr>;

    template <std::derived_from<Type> DerivedType>
    bool is() const;
    template <std::derived_from<Type> DerivedType>
    const DerivedType &as() const;

    virtual bool operator==(const Type &) const;
    virtual unsigned bitWidth() const;

    template <typename ConcreteType, typename... Args>
    static auto make(Args... args);
    // ...
};
\end{lstlisting}

% Разрыв страницы
\clearpage

Наследники в этом случае хранят информацию, необходимую для данного типа.
Например, \verb|PointerType| хранит тип, на который ссылается, и количество элементов:

\begin{lstlisting}[language=C++, caption=Объявление дочернего класса типа]
struct PointerType : public Type {
    const Type::Ptr pointee;
    size_t numElements = 1U;

    // ...
};
\end{lstlisting}

Наконец, атрибут представляется классом \verb|Attribute| и хранит объект одного из фиксированного набора типов.

\begin{lstlisting}[language=C++, caption=Объявление класса атрибута]
struct Attribute {
    using Storage = std::variant<int64_t, double, std::string, Type::Ptr, ArithBinOpKind, LogicBinOpKind /* ... */>;
    Storage storage;

    template <typename VariantType>
    explicit Attribute(const VariantType &value);

    template <typename VariantType> bool is() const noexcept;
    template <typename VariantType> VariantType &as();

    template <typename VariantType> void set(const VariantType &value);
    void clear();
    // ...
};
\end{lstlisting}

Для наглядности при реализации анализаторов также используется класс \verb|Program|, который инкапсулирует программу, переведенную в дерево операций, храня его узел (как правило, операцию \verb|ModuleOp|).

\begin{lstlisting}[language=C++, caption=Объявление класса программы]
struct Program {
    Operation::Ptr root;

    Program(const Operation::Ptr &root);
    // ...
};
\end{lstlisting}
