\newpage
\section{Дерево операций}
\label{sec:optree}

\subsection{Актуальность применения подхода SSA}

Как уже было упомянуто, один из этапов компиляции -- синтаксический анализ.
Реализующий модуль, получая на вход список токенов, в качестве выхода строит синтаксическое дерево.
Такое дерево, помимо прочего, обладает определенными особенностями, среди которых были выделены преимущества и недостатки.

Преимущества:

\begin{itemize}
    \item Синтаксическое дерево легко строится напрямую из списка токенов (или даже текста программы, если лексический анализ совместить с построением дерева) за один проход фактически без дополнительных структур данных.
    \item Синтаксическое дерево является представлением входной программы один-в-один (текст программы может быть восстановлен путем полного обхода дерева), поэтому удобно предоставлять диагностику пользователю (указание точного места в исходном коде).
\end{itemize}

Недостатки:

\begin{itemize}
    \item Процесс семантического анализа дерева нетривиален. Требуется задействовать дополнительные структуры данных для упорядочения информации (список переменных, функций) и т. д.
    \item Применение существенных трансформаций (оптимизаций) является трудоемким: для обнаружения и проверки инвариантов требуется выполнять обходы по несколько раз (анализ использования переменных, вывод типов, поиск определений), что верно и для замены узлов дерева.
\end{itemize}

Для разрешения описанных трудностей, связанных, в частности, с анализом потока данных для выполнения трансформаций, было предложено использовать подход, похожий на SSA.

SSA (static single assignment, статическое единственное присвоение) -- это представление программы, в котором у каждой переменной есть единственное определение, сопровождающееся инициализацией.
Следующие примеры псевдокода демонстрируют одну и ту же программу, записанную в произвольной форме и в форме SSA.

\begin{lstlisting}[language=Python, caption=Программа в произвольной форме]
x = 1
y = x + 1
x = 2
z = x + 1
\end{lstlisting}

\begin{lstlisting}[language=Python, caption=Программа в форме SSA]
x1 = 1
y = x1 + 1
x2 = 2
z = x2 + 1
\end{lstlisting}

Используя свойство единственности присваивания, можно отследить, как было получено то или иное значение, обойдя цепочку определений и использований переменных.

В классическом подходе SSA, используемом в современных компиляторах, все высокоуровневые конструкции языка, такие как ветвления и циклы, разбиваются на последовательность базовых блоков программы, между которыми явно указываются переходы.
Кроме того, вводится понятие \(\phi\)-узлов, связывающих пути, по которым приходит определение переменной из разных блоков при нелинейном исполнении.

В настоящей работе была реализована структура данных, использующая подход SSA в упрощенной форме, достаточной для достижения поставленных целей.
Эта структура, названная деревом операций, описана далее.

\subsection{Описание дерева операций}

Дерево операций -- это дополнительное промежуточное представление исходной программы.
В общем случае узлами дерева являются операции, которые обмениваются между собой значениями, каждое из которых определяется своим типом.

Как видно на рисунке~\ref{fig:optree_scheme}, операция может иметь произвольное число операндов, не более одного результата, произвольное число атрибутов (вспомогательных данных, независимых от других операций), произвольное число вложенных операций внутри, а также объемлющую операцию, в теле которой указанная операция и находится.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{images/optree-scheme.png}
    \caption{Дерево операций.}
    \label{fig:optree_scheme}
\end{figure}

\textbf{Операция} владеет внешними значениями (результатами) и внутренними регистрами.
Результаты видны соседям операции и могут быть операндами других операций, но не видны операциям внутри тела.
Внутренние регистры, наоборот, доступны для использования операциями внутри тела, но снаружи не видны (как переменные во вложенном блоке в C++).
Операция не владеет операндами, так как это результаты или внутренние регистры других операций.
Также внутри хранится имя операции и код, определяющий ее вид (см. п.~\ref{sec:optree_rtti}).
Виды поддерживаемых операций представлены в п.~\ref{sec:optree_operations}.

\textbf{Значение} -- это единоразово определяемый неизменяемый регистр (как const переменная в C++).
Значение нельзя <<изменить>>, но можно создать новую операцию, которая будет иметь нужное значение в качестве результата, а старое значение отбросить (при необходимости удалить порождающую его операцию из дерева).
Значение хранит внутри себя породившую операцию, тип, список использований (операций, среди операндов которых есть указанное значение).

\textbf{Тип} -- это характеристика представления значения; неизменяемая структура, содержащая информацию, полезную для, собственно, представляемого типа.
Система типов в дереве операций сходна с системой типов компилируемого языка (см. п.~\ref{sec:optree_types}).

\textbf{Атрибут} -- это вспомогательные данные, которые используются для анализа операции (какое-либо численное значение, тип, подвид операции, строка и так далее).
Например, операция, описывающая функцию, может иметь имя функции и тип в качестве атрибутов, а операция, описывающая объявление константы - значение и тип константы и т. д.

К особенностям дерева операций можно отнести следующее:

\begin{itemize}
    \item Дерево операций можно построить из синтаксического дерева за один проход.
    \item Анализ использования значения представляет собой обход готового списка.
    \item Добавление или изменение операций прозрачно: операция хранит информацию о своем положении в дереве, значение хранит информацию о связанной операции и типе.
    \item Невозможно восстановить текст исходной программы напрямую, но можно ссылаться на исходный код в диагностике для пользователя, если сохранить ссылки на места в коде внутри операций при их создании из улов синтаксического дерева.
\end{itemize}

\subsection{Динамическая идентификация типов операций}
\label{sec:optree_rtti}

Динамическая идентификация типа данных (run-time type identification, RTTI) -- механизм в некоторых языках программирования, который позволяет определить тип данных переменной или объекта во время выполнения программы.
Существует множество реализаций такого механизма, но наиболее распространёнными являются:

\begin{itemize}
    \item таблица указателей на объекты;
    \item хранение информации об объекте в памяти вместе с ним.
\end{itemize}

Таким образом, операция определения типа сводится либо к поиску в таблице, либо к просмотру нескольких байт до адреса, на который указывает указатель на объект.
У каждого способа есть свои преимущества и недостатки.
К примеру, в первом случае для определения типа переменной требуется производить операции поиска по таблице указателей.
А во втором случае, переменные начинают занимать больше места в оперативной памяти, чем ожидается, ведь к их известному размеру добавляется некоторое количество байтов, нужных для идентификации их типа.

В настоящей работе для операций используется второй подход.
Для создания операций конкретного типа используются классы-адаптеры, каждый из которых представляет определенную операцию и имеет, помимо прочего, статический метод, возвращающий идентификатор типа операции.

\begin{lstlisting}[language=C++, caption=Фрагмент реализации RTTI]
struct ConcreteOp : public BaseOp {
    // ...

    static Operation::SpecId getSpecId() {
        static char specId = 0;
        return &specId;
    }

    static bool implementsSpecById(Operation::SpecId specId) {
        return specId == getSpecId() || BaseOp::implementsSpecById(specId);
    }
};
\end{lstlisting}

Таким образом, при создании конкретной операции в нее также записывается значение идентификатора типа операции из связанного адаптера.
Это позволяет реализовать для класса операции следующие методы, использующие RTTI:

\begin{lstlisting}[language=C++, caption=Интерфейс для доступа к RTTI]
struct Operation {
    using SpecId = void *;
    SpecId specId;
    // ...

public:
    template <typename AdaptorType> bool is() const;
    template <typename AdaptorType> AdaptorType as();
    template <typename AdaptorType> AdaptorType findParent() const;
    // ...
};
\end{lstlisting}

Эти методы позволяют проверить, является ли операция конкретной операцией, привести ее к указанному типу, а также найти в дереве операций среди предков узла операцию, имеющую определенный тип. Реализованный механизм применяется во многих компонентах проекта, работающих с деревом операций, например, в семантическом анализаторе.

\subsection{Система типов в дереве операций}
\label{sec:optree_types}

Для дерева операций была разработана система типов значений, схожая с системой типов данных компилируемого языка (см. п.~\ref{sec:data_types}).
Элементарные типы, наряду со связанными типами из компилируемого языка, представлены в таблице~\ref{tab:optree_basic_types}.

\begin{table}[h]
    \centering
    \caption{Элементарные типы}
    \label{tab:optree_basic_types}
    \begin{tabular}{lp{9cm}p{3cm}}
        \toprule
        \textbf{Название}  & \textbf{Описание}                      & \textbf{Связанный тип} \\
        \midrule
        \verb|IntegerType| & Целочисленное значение размером 8 байт & \verb|int|             \\
        \verb|BoolType|    & Целочисленное значение размером 1 байт & \verb|bool|            \\
        \verb|FloatType|   & Вещественное значение размером 8 байт  & \verb|float|           \\
        \verb|StrType|     & Массив символов размером по 1 байт     & \verb|str|             \\
        \verb|NoneType|    & Данные, не содержащие значения         & \verb|None|            \\
        \bottomrule
    \end{tabular}
\end{table}

Также присутствуют следующие составные типы:

\begin{itemize}
    \item \verb|FunctionType| -- функциональный тип.
          Используется для хранения заголовков функций, задается с помощью типа возвращаемого значения и списка типов аргументов.
    \item \verb|PointerType| -- внутреннее представление указателя.
          Используется для работы с переменными и списками, задается с помощью типа хранимого значения и, опционально, количества элементов, последовательно расположенных в памяти (размера списка).
\end{itemize}

\subsection{Обзор поддерживаемых операций}
\label{sec:optree_operations}

Каждая операция в дереве имеет название и идентификатор ее вида, определяющий ее назначение.
В общем случае, операция является абстракцией над одной или несколькими инструкциями в исполняемом файле, которые соответствуют ее семантике.
Например, арифметической бинарной операции обычно соответствует одна инструкция, вычисляющая результат заданной операции.
В то же время, операция, задающая цикл, при построении исполняемого файла должна быть развернута в целый набор вычислений и условных переходов.

Операции, реализованные в настоящей работе, можно разделить на несколько групп:

\begin{itemize}
    \item \textbf{Фундаментальные операции.}
          Операции в этой группе служат для задания основных "блоков" программы: объявления и вызова функций, введения констант.
          В группу входят следующие операции:
          \verb|ModuleOp, FunctionOp, FunctionCallOp, ReturnOp, ConstantOp|.
    \item \textbf{Вычислительные операции.}
          Эти операции являются репрезентацией вычисления всевозможных арифметико-логических выражений.
          В группу входят следующие операции:
          \verb|ArithBinaryOp, LogicBinaryOp, ArithCastOp, ArithUnaryOp, LogicUnaryOp|.
    \item \textbf{Операции по работе с памятью.}
          Указанной группе принадлежат операции, работающие с низкоуровневым представлением памяти для явной аллокации, загрузки и сохранения значений.
          В группу входят следующие операции:
          \verb|AllocateOp, LoadOp, StoreOp|.
    \item \textbf{Операции над потоком управления.}
          Операции в этой группе используются для декларирования условных и цикловых конструкций, а также их компонентов.
          В группу входят следующие операции:
          \verb|IfOp, ThenOp, ElseOp, WhileOp, ConditionOp, ForOp|.
    \item \textbf{Специальные операции.}
          Эти операции представляют собой высокоуровневые языковые конструкции, которые должны сохраниться и в низкоуровневом представлении.
          В группу входят следующие операции:
          \verb|InputOp, PrintOp|.
\end{itemize}

В соответствии со своим назначением, каждая операция обязана иметь заданное количество операндов, результирующих значений, внутренних регистров, атрибутов.
За проверку корректности этих, а также и других параметров, присущих операции, отвечает семантический анализатор, описанный в п.~\ref{sec:semantizer}.
