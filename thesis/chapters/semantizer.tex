\newpage
\section{Семантический анализ дерева операций}
\label{sec:semantizer}

Семантический анализатор -- компонент для проверки структурной и типизированной корректности различных операций в дереве.
Механизм анализа обеспечит выявление и предотвращение потенциальных ошибок, возникающих при преобразовании исходного кода в промежуточное представление.
Задачи, выполняемые семантическим анализатором:

\begin{itemize}
    \item \textbf{Проверка структуры операций.} Семантический анализатор проверяет количество операндов и результатов для каждой операции в дереве. Например, операция ArithBinaryOp обязана иметь ровно два операнда и один результат. Нарушение данных условий будет идентифицировано как семантическая ошибка.
    \item \textbf{Сопоставление типов.} В зависимости от операции, все операнды и результаты операции должны принадлежать определенным типам. Анализатор выполняет проверку на совместимость типов, гарантируя, что операция может быть корректно выполнена в рамках заданных ограничений.
    \item \textbf{Анализ атрибутов и вложенности.} Каждая операция может содержать атрибуты и вложенные операции. Анализатор удостоверяется в том, что атрибуты соответствуют требованиям операции (например, операция FuncOp содержит строку, отражающую имя функции, в качестве атрибута), и что вложенные операции корректно взаимодействуют с окружающим контекстом.
    \item \textbf{Контекстная целостность.} Путём обеспечения того, что каждая операция имеет корректную объемлющую операцию, анализатор поддерживает целостность и иерархическую организацию дерева операций. Например, операция IfOp должна содержать в своем теле только операцию ThenOp и, возможно, операцию ElseOp.
\end{itemize}

Использование семантического анализа способствует раннему выявлению ошибок, что в свою очередь улучшает общую надежность компилятора и уменьшает вероятность возникновения ошибок на поздних стадиях компиляции.

Проверка описанных инвариантов для каждой операции осуществляется путем обхода дерева операций и вызова функций вида verify<OpType>(OpType op), где OpType -- конкретный класс операции, реализованных для каждой операции. Эти функции, в свою очередь, выполняют последовательность вызовов методов-характеризаторов (traits), а также могут иметь какую-либо дополнительную логику проверки. Характеризатор представляет из себя класс, пример которого приведен ниже.

\begin{lstlisting}[language=C++, caption=Пример класса-характеризатора]
struct HasOperands {
    static bool verify(const Operation::Ptr &op, SemantizerContext &ctx, size_t numOperands);
};
\end{lstlisting}

Вызов указанных методов, в свою очередь, осуществляется не напрямую, а с помощью вспомогательного класса TraitVerifier.

\begin{lstlisting}[language=C++, caption=Объявление класса TraitVerifier]
class TraitVerifier {
    const Operation::Ptr &op;
    SemantizerContext &ctx;
    bool acc;
    public:
    TraitVerifier(const Operation::Ptr &op, SemantizerContext &ctx) : op(op), ctx(ctx), acc(true){};
    bool verified() const;
    template <typename Trait, typename... Args>
    TraitVerifier &verify(Args... args);
};
\end{lstlisting}

Этот класс позволяет строить цепочки проверок следующего вида, что дает возможность не выполнять проверки после того, как одна из них в цепочке была провалена:

\begin{lstlisting}[language=C++, caption=Пример семантической верификации]
verifier.verify<HasOperands>(0)
        .verify<HasResults>(0)
        .verify<HasAttributes>(2)
        .verify<HasNthAttrOfType<std::string>>(0)
        .verify<HasNthAttrOfType<FunctionType>>(1);
\end{lstlisting}
