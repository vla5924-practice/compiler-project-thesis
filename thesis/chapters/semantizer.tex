\newpage
\section{Семантический анализ дерева операций}
\label{sec:semantizer}

Семантический анализатор -- компонент для проверки структурной и типизированной корректности различных операций в дереве.
Механизм анализа обеспечит выявление и предотвращение потенциальных ошибок, возникающих при преобразовании исходного кода в промежуточное представление.
Задачи, выполняемые семантическим анализатором:

\begin{itemize}
    \item \textbf{Проверка структуры операций.} Семантический анализатор проверяет количество операндов и результатов для каждой операции в дереве. Например, операция ArithBinaryOp обязана иметь ровно два операнда и один результат. Нарушение данных условий будет идентифицировано как семантическая ошибка.
    \item \textbf{Сопоставление типов.} В зависимости от операции, все операнды и результаты операции должны принадлежать определенным типам. Анализатор выполняет проверку на совместимость типов, гарантируя, что операция может быть корректно выполнена в рамках заданных ограничений.
    \item \textbf{Анализ атрибутов и вложенности.} Каждая операция может содержать атрибуты и вложенные операции. Анализатор удостоверяется в том, что атрибуты соответствуют требованиям операции (например, операция FuncOp содержит строку, отражающую имя функции, в качестве атрибута), и что вложенные операции корректно взаимодействуют с окружающим контекстом.
    \item \textbf{Контекстная целостность.} Путём обеспечения того, что каждая операция имеет корректную объемлющую операцию, анализатор поддерживает целостность и иерархическую организацию дерева операций. Например, операция IfOp должна содержать в своем теле только операцию ThenOp и, возможно, операцию ElseOp.
\end{itemize}

Использование семантического анализа способствует раннему выявлению ошибок, что в свою очередь улучшает общую надежность компилятора и уменьшает вероятность возникновения ошибок на поздних стадиях компиляции.

\subsection{Проверка инвариантов}

Проверка описанных инвариантов для каждой операции осуществляется путем обхода дерева операций и вызова функций вида \verb|verify<OpType>(OpType op)|, где OpType -- конкретный класс операции, реализованных для каждой операции.
Эти функции, в свою очередь, выполняют последовательность вызовов методов-характеризаторов, а также могут иметь какую-либо дополнительную логику проверки.
Характеризатор представляет из себя класс, пример которого приведен ниже.

\begin{lstlisting}[language=C++, caption=Пример класса-характеризатора]
struct HasOperands {
    static bool verify(const Operation::Ptr &op, SemantizerContext &ctx, size_t numOperands);
};
\end{lstlisting}

Вызов указанных методов, в свою очередь, осуществляется не напрямую, а с помощью вспомогательного класса TraitVerifier.

\begin{lstlisting}[language=C++, caption=Интерфейс класса TraitVerifier]
class TraitVerifier {
  public:
    TraitVerifier(const Operation::Ptr &op, SemantizerContext &ctx) : op(op), ctx(ctx), acc(true){};
    bool verified() const;
    template <typename Trait, typename... Args>
    TraitVerifier &verify(Args... args);
};
\end{lstlisting}

Этот класс позволяет строить цепочки проверок следующего вида, что дает возможность не выполнять проверки после того, как одна из них в цепочке была провалена:

\begin{lstlisting}[language=C++, caption=Пример семантической верификации]
verifier.verify<HasOperands>(0)
        .verify<HasResults>(0)
        .verify<HasAttributes>(2)
        .verify<HasNthAttrOfType<std::string>>(0)
        .verify<HasNthAttrOfType<FunctionType>>(1);
\end{lstlisting}

\subsection{Проверка доминирования}

Определение SSA, взятое за основу при разработке дерева операций, позволяет говорить о свойстве доминирования.
По отношению к языку программирования свойство означает, что каждое использование переменной не предшествует точке ее определения.
По существу, это значит, что каждая переменная объявлена до использования, а также не используется вне ее области видимости.

В теории графов доминированием называется бинарное отношение на узлах ориентированного графа с определенным входным узлом, показывающее преимущество при прохождении пути от входного узла \(r\).
Говорят, что узел графа \(p\) доминирует узел графа \(q\) (или \(p\) является доминатором для \(q\)), если любой путь от \(r\) до \(q\) проходит через \(p\).
Каждый узел графа доминирует сам себя.
Кроме того, можно ввести определение строгого доминирования, совпадающее с приведенным определением за исключением того, что каждый узел графа не будет являться строгим доминатором для самого себя.

Свойство доминирования для языка программирования, описанное выше, можно проверить с помощью дерева доминаторов -- вспомогательной структуры данных, построенной для конкретного дерева операций.
В нем каждый узел доминирует только над своими потомками в исходном дереве, а входной узел является корнем.
У каждого узла в дереве доминаторов, кроме корневого, должен быть ровно один родительский узел -- непосредственный доминатор соответствующего ему узла в исходном дереве -- и произвольное количество узлов-потомков.
Дерево доминаторов позволяет сравнительно эффективно выявлять, является ли один узел доминатором другого или нет.
Чтобы это проверить, нужно пройти по дереву от предполагаемого доминируемого узла до корня и проверить, встретится ли на этом пути предполагаемый доминатор.
\cite{habr_dominance}

Дерево доминаторов представлено соответствующим классом с методами, позволяющими выполнять описанные проверки.

\begin{lstlisting}[language=C++, caption=Объявление класса DominanceTree]
struct DominanceTree {
    DominanceTree() = delete;
    explicit DominanceTree(const Operation::Ptr &rootOp);

    bool dominates(const Operation::Ptr &dominator, const Operation::Ptr &dominated) const;
    bool properlyDominates(const Operation::Ptr &dominator, const Operation::Ptr &dominated) const;

  private:
    struct Node {
        Node *parent = nullptr;
    };
    Node *root;
    std::unordered_map<const Operation *, const Node *> traversedOps;

    // ...
};
\end{lstlisting}

Для построения дерева доминаторов выполняется рекурсивный обход дерева операций, начиная от корня.
Первая вложенная операция становится потомком операции, ее объемлющей, а каждая последующая операция становится потомком предыдущей.
Исключение составляют операции \verb|ModuleOp| (вложенные в нее операции \verb|FunctionOp| равноправны, и она становится их общим предком), \verb|IfOp| (аналогично, операции \verb|ThenOp| и \verb|ElseOp| не доминируют друг друга) и \verb|ConditionOp| (эта операция не доминирует следующую за ней).
При обходе также сохраняется соответствие узлов дерева операций узлам дерева доминаторов.

В дальнейшем, во время семантического анализа дерева операций, проверка свойства доминирования выполняется следующим образом:

\begin{enumerate}
    \item Для указанного дерева операций строится дерево доминаторов.
    \item Для каждой операции \(Def\) проверяется следующее утверждение: верно ли, что каждая из операций \(Use\), имеющая результат операции \(Def\) в качестве операнда, строго доминирует \(Def\).
    \item Аналогичное утверждение проверяется для внутренних регистров каждой операции в дереве. 
\end{enumerate}

Если во всех случаях утверждение верно, то дерево операций считается корректным с точки зрения свойства доминирования.
В противном случае дерево не может быть использовано для дальнейших трансформаций.
