\newpage
\section{Генератор промежуточного представления LLVM IR}
\label{sec:llvmir_codegen}

Для упрощения трансляции кода в машиночитаемый двоичный файл на этапе разработки компилятора можно частично «передать» эту задачу фреймворку LLVM.

\subsection{Актуальность использования LLVM}

LLVM (аббревиатура, может быть расшифрована как Low-Level Virtual Machine) -- проект программной инфраструктуры для создания компиляторов и сопутствующих им утилит, который состоит из набора компиляторов языков высокого уровня (так называемых «фронтендов»), системы оптимизации, интерпретации и компиляции в машинный код.

Одна из особенностей фреймворка заключается в том, что он может создавать машинный код для множества архитектур, в том числе ARM, x86, x86-64, используя в качестве основы текст программы, написанный на языке промежуточного представления LLVM IR.
Этот язык представляет собой вариацию «высокоуровневого ассемблера», поддерживающего всевозможные арифметические и логические операции, работу с памятью, вызовы процедур, составные типы данных (структуры), манипуляции с регистрами и т. д.

Таким образом, для достижения поставленных в текущей практической работе задач можно выполнить все необходимые преобразования исходного кода на описанном в п.~\ref{sec:language} языке (предобработка, лексический анализ, синтаксический анализ, семантический анализ, итоговая оптимизация), затем путем обхода построенного дерева операций и выбора соответствующих инструкций LLVM IR создать текстовый файл, содержащий описанное промежуточное представление программы, и в итоге выполнить финальную трансляцию в объектный файл с помощью утилиты LLCompile (llc) из пакета LLVM.
Полученный файл может быть использован, например, компилятором clang или компоновщиком ld напрямую для связывания со стандартной библиотекой языка Си и получения исполняемого файла \cite{llvm_docs}.

\subsection{Основной класс LLVMIRGenerator}

В программной реализации генератор промежуточного представления LLVM IR представлен в виде класса \verb|LLVMIRGenerator|.
Содержательная часть объявления класса выглядит следующим образом:

\begin{lstlisting}[language=C++, caption=Объявление класса LLVMIRGenerator]
class LLVMIRGenerator {
    void visit(const optree::Operation::Ptr &op);
    void visitBody(const optree::Operation::Ptr &op);

    void visit(const optree::ModuleOp &op);
    void visit(const optree::FunctionOp &op);
    void visit(const optree::ArithBinaryOp &op);
    // ...

  public:
    explicit LLVMIRGenerator(const std::string &moduleName);
    void process(const optree::Program &program);
    void dumpToFile(const std::string &filename) const;
};
\end{lstlisting}

Основным методом, выполняющим непосредственно генерацию кода, является \verb|process|.
Этот метод принимает дерево операций, полученное в процессе компиляции (см. п.~\ref{sec:optree}).
Построенный код может быть в дальнейшем сохранен в файл с помощью метода \verb|dumpToFile|.

Принцип построения кода состоит в обходе синтаксического дерева и добавления инструкций с помощью соответствующего модуля из состава фреймворка LLVM.
Обход дерева производится рекурсивно от корня и начинается внутри метода \verb|process|.
Методы, отвечающие за обработку узлов дерева различных типов, называются \verb|visit|.


\subsection{Особенности реализации функций ввода-вывода}

В приведенном языке для ввода и вывода данных определены две «встроенные» функции \verb|print| и \verb|input|, реализация которых не может быть переопределена пользователем.
Тем не менее на самом деле обе они не имеют под собой реализации на этом языке, и в местах их вызова происходит обращение к стандартной библиотеке языка Си.

Более того, в силу специфики использования функции \verb|print| и \verb|input| можно считать в большей степени языковыми конструкциями, нежели функциями.
Функция \verb|print| может принимать одно или несколько выражений любого из поддерживаемых типов в качестве аргументов (в языке C++, например, такое поведение функций называется перегрузкой), что для пользовательских функций запрещено.
Функция \verb|input| ведет себя еще более нестандартно: она может находиться только в операциях присваивания и только в качестве правого операнда, при этом не принимает аргументов, но тип возвращаемого значения при ее вызове определяется типом переменной в роли левого операнда того же выражения (фигурально такое поведение можно назвать «перегрузкой по типу возвращаемого значения», по аналогии с обычными перегрузками из C++).

Рассмотрим теперь, каким образом вызовы этих функций компилируются во время генерации кода LLVM IR.

В месте вызова функции \verb|print| происходит вставка инструкции LLVM IR, декларирующей вызов функции \verb|printf|.
Как известно, эта функция принимает форматирующую строку и список выражений, тип которых должен совпадать с типами, соответствующими шаблонным последовательностям в форматирующей строке.
Таким образом, при генерации кода инструкция вызова \verb|printf| содержит два передаваемых аргумента:

\begin{itemize}
  \item форматирующую строку, состоящую из одной шаблонной последовательности (типу int соответствует \verb|%d|, типу float соответствует \verb|%lf|, типу str соответствует \verb|%s|, остальные типы содержат фиксированное множество значений и свою строку для каждого из значений: \verb|True|, \verb|False|, \verb|None|);
  \item значение выражения определенного типа, которое должно быть выведено в стандартный поток вывода.
\end{itemize}

В месте вызова функции \verb|input| происходит аналогичная вставка вызова функции \verb|scanf|.
Принцип использования этой функции отличается тем, что вместо значения выражения должен передаваться адрес переменной, в которую будет записано значение, полученное из стандартного потока ввода.
