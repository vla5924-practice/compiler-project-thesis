\newpage
\section{Генератор промежуточного представления LLVM IR}
\label{sec:llvmir_codegen}

Для упрощения трансляции кода в машиночитаемый двоичный файл на этапе разработки компилятора можно частично «передать» эту задачу фреймворку LLVM.

\subsection{Актуальность использования LLVM}

LLVM (аббревиатура, может быть расшифрована как Low-Level Virtual Machine) - проект программной инфраструктуры для создания компиляторов и сопутствующих им утилит, который состоит из набора компиляторов языков высокого уровня (так называемых «фронтендов»), системы оптимизации, интерпретации и компиляции в машинный код.

Одна из особенностей фреймворка заключается в том, что он может создавать машинный код для множества архитектур, в том числе ARM, x86, x86-64, используя в качестве основы текст программы, написанный на языке промежуточного представления LLVM IR.
Этот язык представляет собой вариацию «высокоуровневого ассемблера», поддерживающего всевозможные арифметические и логические операции, работу с памятью, вызовы процедур, составные типы данных (структуры), манипуляции с регистрами и т. д.

Таким образом, для достижения поставленных в текущей практической работе задач можно выполнить все необходимые преобразования исходного кода на описанном в п.~\ref{sec:language} языке (предобработка, лексический анализ, синтаксический анализ, семантический анализ, итоговая оптимизация), затем путем обхода построенного дерева операций и выбора соответствующих инструкций LLVM IR создать текстовый файл, содержащий описанное промежуточное представление программы, и в итоге выполнить финальную трансляцию в объектный файл с помощью утилиты LLCompile (llc) из пакета LLVM.
Полученный файл может быть использован, например, компилятором clang или компоновщиком ld напрямую для связывания со стандартной библиотекой языка Си и получения исполняемого файла.

\subsection{Основной класс LLVMIRGenerator}

В программной реализации генератор промежуточного представления LLVM IR представлен в виде класса IRGenerator.
Содержательная часть объявления класса выглядит следующим образом:

\begin{lstlisting}[language=C++, caption=Объявление класса LLVMIRGenerator]
class LLVMIRGenerator {
  public:
    IRGenerator(const std::string &moduleName);
    void process(const SyntaxTree &tree);
    void writeToFile(const std::string &filename);
  private:
    llvm::Value *visitNode(Node::Ptr node);
    llvm::Value *visitBinaryOperation(Node *node);
    llvm::Value *visitFloatingPointLiteralValue(Node *node);
    llvm::Value *visitFunctionCall(Node *node);
    // ...
    void processNode(Node::Ptr node);
    void processExpression(Node *node);
    void processFunctionDefinition(Node *node);
    void processIfStatement(Node *node);
    // ...
};
\end{lstlisting}

Основным методом, выполняющим непосредственно генерацию кода, является process.
Этот метод принимает дерево операций, полученное в процессе компиляции (см. п.~\ref{sec:optree}).
Построенный код может быть в дальнейшем сохранен в файл с помощью метода writeToFile.

Принцип построения кода состоит в обходе синтаксического дерева и добавления инструкций с помощью соответствующего модуля из состава фреймворка LLVM.
Обход дерева производится рекурсивно от корня и начинается внутри метода process.
Как видно в представленном фрагменте кода, часть методов, отвечающих за обработку узлов дерева различных типов, имеют в названии префикс process или visit.
Особенность методов visit состоит в том, что они в результате просмотра узла возвращают вычислимое значение и используются для обхода арифметико-логических выражений.
Методы же, имеющие названия, начинающиеся со слова process, обходят узлы, которые по своей сути не являются частями выражений (например, конструкции с циклами и заголовки функций).

\subsection{Особенности реализации функций ввода-вывода}

В приведенном языке для ввода и вывода данных определены две «встроенные» функции print и input, реализация которых не может быть переопределена пользователем.
Тем не менее на самом деле обе они не имеют под собой реализации на этом языке, и в местах их вызова происходит обращение к стандартной библиотеке языка Си.

Более того, в силу специфики использования функции print и input можно считать в большей степени языковыми конструкциями, нежели функциями.
Функция print может принимать одно выражение любого из поддерживаемых типов в качестве аргумента (в языке C++, например, такое поведение функций называется перегрузкой), что для пользовательских функций запрещено.
Функция input ведет себя еще более нестандартно: она может находиться только в операциях присваивания и только в качестве правого операнда, при этом не принимает аргументов, но тип возвращаемого значения при ее вызове определяется типом переменной в роли левого операнда того же выражения (фигурально такое поведение можно назвать «перегрузкой по типу возвращаемого значения», по аналогии с обычными перегрузками из C++).

Рассмотрим теперь, каким образом вызовы этих функций компилируются во время генерации кода LLVM IR.

В месте вызова функции print происходит вставка инструкции LLVM IR, декларирующей вызов функции printf.
Как известно, эта функция принимает форматирующую строку и список выражений, тип которых должен совпадать с типами, соответствующим шаблонным последовательностям в форматирующей строке.
Таким образом, при генерации кода инструкция вызова printf содержит два передаваемых аргумента:

\begin{itemize}
  \item форматирующую строку, состоящую из одной шаблонной последовательности (типу int соответствует "\%d", типу float соответствует "\%lf", типу str соответствует "\%s", остальные типы содержат фиксированное множество значений и свою строку для каждого из значений: "True", "False", "None");
  \item значение выражения определенного типа, которое должно быть выведено в стандартный поток вывода (stdout).
\end{itemize}

В месте вызова функции input происходит аналогичная вставка вызова функции scanf.
Принцип использования этой функции отличается тем, что вместо значения выражения должен передаваться адрес переменной, в которую будет записано значение, полученное из стандартного потока ввода (stdin).
